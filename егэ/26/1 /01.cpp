/*
Системный администратор раз в неделю создаёт архив пользовательских файлов. 
Однако объём диска, куда он помещает архив, может быть меньше, чем суммарный объём архивируемых файлов.

Известно, какой объём занимает файл каждого пользователя.
Администратор сохраняет файлы по следующему правилу: 
1) выбирается файл максимального размера, который может быть записан на диск, 
2) выбирается файл минимального размера, который может быть записан на диск. 
Данный сценарий повторяется до тех пор, пока на диск нельзя будет записать ни одного из оставшихся файлов.

Входные данные.
В первой строке входного файла находятся два числа: S – размер свободного места на диске (натуральное число, не превышающее 100 000)
N – количество пользователей (натуральное число, не превышающее 1000).
В следующих N строках находятся значения объёмов файлов каждого пользователя 
(все числа натуральные, не превышающие 1000), каждое в отдельной строке.

Запишите в ответе два числа:
сначала наибольшее число пользователей, чьи файлы могут быть помещены в архив, 
затем размер последнего сохраненного файла.

Пример входного файла:
100 5
80 
30
10
5
7

При таких исходных данных можно сохранить файлы трех пользователей. 
Объёмы этих трех файлов 80, 5 и 10. 
Последний выбранный файл имеет размер 10 , 
поэтому ответ для приведённого примера: 3, 10
*/

#include <bits/stdc++.h>
using namespace std;

#define fast_cin() \
    ios_base::sync_with_stdio(0); \
    cin.tie(NULL); \
    cout.tie(NULL)
#define ln "\n"


int main() {
	fast_cin();
	ifstream f("26.txt");
	int size, n;
	f >> size >> n;
	vector <int> all;
	int obj;
	for (int i = 1; i != 1001; i++) { // посмотрел, сколько в файле строк  P.S (while(!eof) приводит к ошибке (почему и как сложно сказать, буду смотреть)) 
		f >> obj;
		all.push_back(obj);
	}
//	cout << all.size() << ln << ln;
	sort(begin(all), end(all));
	vector <int> res;
//	cout << accumulate(res.begin(), res.end(), 0) + *max_element(begin(all), end(all));
	while (accumulate(res.begin(), res.end(), 0) + *min_element(begin(all), end(all)) < size) {
		if (accumulate(res.begin(), res.end(), 0) + *max_element(begin(all), end(all)) < size) { // по этой задаче лучше указывать макс элемент через итератор, так как через индексацию приведёт к переполнению (owerflow)
			res.push_back(*max_element(begin(all), end(all)));
			all.pop_back();
		} 
		// continue в этом случае ни в коем случае не писать, так как программа "ляжет" и не будет адекватно работать
		if (accumulate(res.begin(), res.end(), 0) + *min_element(begin(all), end(all)) < size) {
			res.push_back(*min_element(begin(all), end(all)));
			auto iter = all.cbegin(); // задача сработала только при таком способе задания значения итератора
			all.erase(iter);
		}
	}
	cout << res.size() << " "; // вывод количества подходящих элементов
	for (int i = res.size() - 1; i != 0; i--) {
		cout << res[i]; // если вызвать сразу res[-1] то компилятор выдаст неккоректный ответ, поэтому вывод осуществляется таким образом (к слову, *end(res) и его интепретации также не работают)
		break;
	}
//	cout << ln << accumulate(res.begin(), res.end(), 0) << ln;
//	cout << all.size() << ln << ln;
//	for (int i = 0; i != all.size(); i++) {
//		cout << all[i] << " ";
//	}
	return 0;
}

/*
строки кода, которые заключены в комментариях - моя отладка кода, отражающая промежуточные или итоговые результаты
отрегулировать код и прийти к правильному ответу мне помог код на Python.
*/

