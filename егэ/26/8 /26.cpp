/*
Система наблюдения ежеминутно фиксирует вход и выход сотрудников из офиса (в минутах, прошедших от начала суток). Считается, что в моменты фиксации входа и выхода сотрудник находится в офисе. Нулевая минута соответствует моменту начала рабочего дня в офисе, который длится 24 ч в сутки без перерыва.
Менеджер компании анализирует данные системы наблюдения за прошедшие сутки, и выявляет непересекающиеся отрезки времени наибольшей длины, в течение которых число сотрудников, находящихся в офисе, не изменялось.
Входной файл содержит время входа и выхода каждого сотрудника компании. Определите минуту, когда в предпоследний раз за сутки число сотрудников поменялось, и укажите наибольшую длину отрезка времени, когда количество сотрудников оставалось неизменным.
 
Входные данные
В первой строке входного файла находится натуральное число N (N ≤ 100 000) – количество сотрудников компании. Следующие N строк содержат пары чисел, обозначающих соответственно время входа и время выхода сотрудника (все числа натуральные, не превышающие 1440).
Запишите в ответе два натуральных числа: сначала минуту, когда в предпоследний раз за сутки число сотрудников поменялось, а затем
наибольшую длительность промежутка времени, при котором количество сотрудников оставалось неизменным.
*/

#include <bits/stdc++.h>
using namespace std;

int main() {
    ifstream f("26.txt");
    int n; f >> n;
    vector <int> all(1441); // создаем вектор, где индексы будут равны соответствующей минуте
    for (int i = 0; i != n; i++) {
        int in, out; f >> in >> out;
        all[in]++; all[out]--; // заполняем минуты по принципу: вход -> +1; выход -> -1
    }
    int k = 0;
    for (int i = all.size() - 1; i != 0; i--) {
        if (all[i] != 0) {
            cout << i << " "; // берем второе значение - наш первый ответ
            k++;
            if (k == 2) break;
        }
    }
    
    // cout << endl;
    // for (int i = 0; i != all.size(); i++) {cout << all[i] << " ";}
    // cout << endl;
    
    int mx = 0;
    int cnt = 0;
    for (int i = 0; i != all.size() + 1; i++) {
        if (all[i] == 0) cnt++;
        // cout << cnt << endl;
        if (all[i] != 0) {
            if (mx < cnt) {
                mx = cnt;
            }
            cnt = 0;
        }
    }
    cout << endl << mx + 1; // предпологаю, что где-то ошибаюсь либо я, либо файл кривой, но ответ 13, если убрать +1, будет 12
    
}
